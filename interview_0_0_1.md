# 목차
- [소프트웨어 공학](#소프트웨어-공학)
- [Java](#java)
- [Spring](#spring)
- [DB & NoSql](#DB-&-NoSql)
- [디자인 패턴](#디자인-패턴)
- [자료구조](#자료구조)
- [알고리즘](#알고리즘)
- [네트워크](#네트워크)


# 소프트웨어 공학

## 객체지향

## SOLID
  1. SRP - 단일 책임 원칙 (Single responsibility principle)
    * 한 클래스는 하나의 책임만 가져야 한다.
    * 
  2. OCP - 개방-폐쇄 원칙 (Open/closed principle)
    * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    * 
  3. LSP - 리스코프 치환 원칙 (Liskov substitution principle)
    * 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상작동 해야한다.(계약에 의한 설계)
    * 
  4. ISP - 인터페이스 분리 원칙 (Interface segregation principle)
    * 인터페이스는 그 인터페이스를 사용하는 클라언트를 기준을 분리 해야한다.
    * 
  5. DIP - 의존관계 역전 원칙 (Dependency inversion principle)
    * 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준의 모듈이 고수준 모듈에 정의한 추상 타입에 의존 해야한다.
    * 추상화에 의존해야지, 구체화에 의존하면 안된다

단칙 책임 원칙과 인터페이스 분리 원칙은 객체가 커지지 않도록 막아 준다. 객체가 많은 기능을 가지게되면, 객체가 가진 기능의 변경 여파가 그 객체의 다른 기능에까지 번지게되고 이는 다시 다른 기능을 사용하는 클라이언트에까지 영향을 준다. 객체가 단일 책임을 갖게 하고 클라이언트 마다 다른 인터페이스를 사용하게 함으로써 한 기능의 변경이 다른 곳까지 미치는 영향을 최소화할 수 있고, 이는 결국 기능 변경 보다 쉽게 할 수 있도록 만들어 준다.

리스코프 치환 원칙과 의존 역전 원칙은 개방 폐쇄 원칙을 지원한다. 개방 폐쇄 원칙은 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장을 하면서 기존 코드를 수정하지 않도록 만들어준다. 여기서, 변화되는 부분을 추상화할 수 있도록 도와주는 원칙이 바로 의존 역전 원칙이고, 다형성을 도와주는 원칙이 리스코프 치환 원칙인 것이다.

또한, SOLID 원칙은 사용자 입장에서의 기능을 사용을 중시한다. 인터페이스 분리 원칙은 클라이언트 입장에서 인터페이스를 분리하고 있으며, 의존 역전 원칙 역시 저수준 모듈을 사용하고 고수준 모듈입장에서 추상화 타입을 도축하도록 유도한다. 또 리스코프 치환 원칙은 사용자에게 기능 명세를 제공하고, 그 명세에 따라 기능을 구현할 것을 약속한다. 이 처럼 SOLID 원칙은 사용자 관점에서 설계를 지향하고 있다.


## 개발 방법론

## DDD
  * 참고
    * https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice

### 도메인 모델 아키텍처
  * 사용자 인터페이스(표현) : 사용자의 요청을 처리하고 사용자에게 정보를 보여줌(외부 시스템도 될 수 있음)
  * 응용 : 사용자가 요청한 기능을 실행. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행
  * 도메인 : 시스템이 제공할 도메인의 규칙을 구현
  * 인프라스트럭처 : 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동 처리
  
  > 계층 구조는 특정상 상위 계층에서 하위 계층으로 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
  > 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용한다. (응용계층이 바로 아래 계층인 도메인 계층의 의존하지 않고 인프라스트럭처 계층에 의존하기도 함)

### DIP
  * 고수준 모듈이 제대로 동작하려면 저수준 모델을 사용해야 한다. 그런데 고수준 모듈이 저수준 모듈을 사용하면 구현 변경과 테스트가 어려움. 이 문제를 해결 하기 위해 저수준 모듈에 의존하도록 바꾼다. 고수준 모듈을 구현하려면 저수준 모듈을 사용 해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존하도록 하는거. 인터페이스 등을 이용하여 고수준 모듈을 추상화하여 의존 하도록 함
  * 응용 계층과 인프라스트럭처 계층을 인터페이스를 두고 DIP를 적용 변경에 유용

### 도메인 영역의 주요 구성 요소
  #### Entity
    * 고유의 식별자를 갖는 객체로 자신의 라이프사이클를 가짐
    * 도메인의 고유한 개념을 표현, 데이터를 포함하며 관련된 기능을 함께 제공
  #### Value Object
    * 고유 식별자를 갖지 않음. 도메인 객체의 속성을 표현 할 때 사용
    * 엔티티의 속성으로 사용될 뿐만 아니라 다른 벨류 타입의 속성으로도 사용
  #### Service 
    * 특정 엔ㅌ티에 속하지 않은 도메인 로직
    * Domain Object에 위치시키기 어려운 operation을 가지는 객체
    * 여러 Domain Object 다루는 연산 Service의 오퍼레이션은 일반적으로 stateless
    * Domain Object에 해당되는 역할을 service operation으로 만드는 경우 도메인 역할을 침범하여 강 결합이 일어남
  #### Module
    * 유사 작업 및 개념을 그룹화 하여 복잡도를 감소시키는 기법
    * 응집도가 높은 모듈은 모듈간의 관계는 약 결함
    * Java로 구현하는 경우 package로 구성
  #### Aggregate
    * 관련된 엔터리와 벨류 객체를 개념적으로 하나로 묶은 것
    * 일관성과 트랜잭션, 분산의 단위, 캡슐화를 통한 복잡성 관리
    * 경계를 갖음, 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않음
    * 각 애그리거트는 자신만 관리할 뿐 다른 애그리거트를 관리 하지 않음
    * 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항
    * aggreate root : 애그리거트에 속한 모든 객체가 일관된 상태를 유지할수 있도록 하는 주체
  #### Factory
    * 복잡한 엔티티의 생성 절차에 갭슐화 할 수 있는 개념
    * 생성하기 복잡한 Aggregate내의 여러 객체를 동시에 생성
    * 생성시 Aggregate의 일관성 유지
  #### Repository
    * 도메인 영역과 데이터 인프라스트럭쳐 계층의 분리하여 데이터 계층에 대한 결합도를 낮추기 위한 방안
    * 생성된 Aggregate에 대한 영속성 관리, 조회, 등록, 수정, 삭제시 Aggregate의 일관성 유지
    * DB 및 데이터 저장소의 데이터를 조회하고 저장등의 역할

### 응용 서비스
  #### 응용 서비스의 역할
    * 응용 서비스는 도메인 객체를 사용하여 요청한 기능을 실행
    * 도메인 영역과 표현영역을 연결해주는 파사드 역할
    * 도메인의 상태 변경을 트랜잭션 처리
    * 도메인 로직은 응용 서비스 영역에 구현하지 않는다.(응집도가 떨어지고 중복코드 발생 가능성이 높아짐)
    * 도메인 로직은 도메인 영역에 모아서 코드 중복이 발생하지 않도록 하고 응집도를 높여야 함

  #### 응용 서비스의 구현
    * 구분되는 기능별로 서비스 클래스를 구현하는 방식 추천(XXX{기능명}Service)
    * 각각 클래스 별로 필요한 의존 객체만 포함함으로 다른 기능을 구현한 코드에 영향을 받지 않음
    * 각 기능마다 동일한 로직을 필요 할 경우 XXXServiceHelper 와 같은 클래스에 로직을 구현해서 코드가 중복되는 것을 방지
    * XXXService 이러한 서비스 클래스는 안티패턴(다형성을 만족시키기 힘듬)

  #### 응용 서비스의 인터페이스와 클래스
    * 인터페이스가 필요한 경우
      * 구현 클래스가 여러 개인 경우
      * 런타임에 구현 객체를 교체해야 할 경우(보통 런타임에 교체하는 경우가 별로 없음)
    * 인터페이스와 클래스를 따로 구현하면 소스 파일이 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조만 복잡해짐
    * 인터페이스가 명확하게 필요하기 전까지는 응요 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계라 생각

  #### 메소드 파리미터와 값 리턴
    * 메소드에 데이터를 전달할 때 요청 파리미터가 두개 이상 존재하면 데이터 전달을 위한 별로 클래스를 사용하는 것이 편리
    * 리턴값으로 애그리거트 자체를 리턴하면 편리하지만 코드의 응집도를 낮추는 원인이 됨(응용서비스와 표현 영역에 분산시킴)

  #### 표현 영역에 의존하지 않기
    * 응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안됨
    * 응용 서비스에서 표현 영역에 대한 의존성이 발생하면 응용 서비스만 단독으로 테스트하기 힘듬

  * 도메인 이벤트처리
    * 도메인 영역에서 발생시킨 이벤트를 처리

### 표현영역
  * 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어하는 역할
  * 사용자의 요청을 알맞는 응용 서비스에 전달하고 결과를 사용자에게 제공
  * 사용자의 세션을 관리

### 값 검증
  * 표현영역 : 필수 값, 값의 형식, 범위 등을 검증
  * 응용서비스 : 데이이터의 존재 유무와 같은 논리적인 오류를 검증

### 도메인 서비스
  * 여러 애그리거트가 필요한 기능을 구현을 한 애그리거트에 억지로 구현하는 것보다 도메인 서비스를 이용하해서 도메인 개념을 명시적으로 드러 내도록 한다. 

### 애그리거트 트랜잭션 관리
  #### 선점 잠금(비관적 잠금 - Pessimistic Lock)
    * 선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식
    * 교착상태에 빠질수 있음(timeout 설정하며 피할수 있음)
  #### 비선전 잠금(낙관적 잠금 - Optimisstic Lock)
    * 변경한 데이터를 실제 DBMS에서 반영하는 시점에 변경 가능 여부를 확인 하는 방식
    * 다른 트랜잭션이 먼저 데이터를 수정해서 버전 값이 바뀌면 데이터 수정에 실패하게 됨

### 도메인 모델과 Bounded Countext
  * 한 개의 모델로 모든 하위 도메인을 표현하는 시도는 올바른 방법이 아니며 표현할 수도 없음
  
  #### Bounded Context
    * 모델의 경계를 결정(업무의 경계)
    * Bounded Context는 Module과 다른 영역, 도메인 모델에 집중하는 영역
    * 잘 구성된 Bounded Context내의 어플리케이션은 독립적 구성이 가능해야 함
    * 다른 Context간의 모델 및 데이터 참조는 정확히 인터페이스(API)만으로 통시하여야 함
  
  #### Bounded Contextd의 구현
    * 도메인 기능을 사용자에게 제공하는데 필요한 표현 영역, 응용 서비스, 인프라 영역 등 모두 포함

  ### 이벤트
    * 시스템 간의 강결합을 없애 수 있는 방법(비동기 이벤트)
    * 과거에 벌어진 사건

    #### 이벤트 관련 구성 요소
      * 엔티티, 벨류, 도메인 서비스와 같은 도메인 객체
      * 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생
      * 클래스 이름은 과거 시제를 사용

    #### 이벤트 용도
      * 트리거 : 도메인의 상태가 바뀔 때 다른 후처리
      * 데이터 동기화 : 서로 다른 시스템 간의 데이터 동기화 

    #### 이벤트 장점
      * 서로 다른 도메인 로직이 섞이는 것을 방지 할 수 있음
      * 기능 확장이 용이

    #### 이벤트, 핸들러, 디스패치 구현
      * 이벤트 클래스 : 이벤트 처리하는 데 필요한 최소한의 데이터만 포함
      * Event Handler 인터페이스 
      * Event Dispatch : 이벤트 발행, 이벤트 핸들러 등록 등의 기능 제공

    #### 메시징 시스템을 이용한 비동기 구현
      * 이벤트가 발생하면 이벤트 디스패처는 이벤트를 메시지 큐에 보냄, 메시지 큐는 이벤트를 메시지 리스너에 전달하고 메시지는 리스터는 알맞은 이벤트 핸들러를 이용해서 이벤트 처리

  ### CQRS
    * 상태를 변경하는 기능과 상태 정보를 조회하는 기능을 분리하여 도메인을 구성하는 것
    * 도메인 모델 관점에서 상태변경 기능은 주로 한 Aggregate의 상태를 변경(수정)
    * 조회기능은 하나의 Aggregate도 조회할 수 있지만, 두 개 이상의 Aggregate에서 데이터를 조회할 수 있음

  ### Event Sourcing
    * Application내의 모든 Action을 이벤트로 전환해서 이벤트 스트림을 별도의 Databasedp 저장하는 방식
    
    #### 장점
      * 트랜잭션 처리 중 경합이 없음
      * 모든 변경 내역이 이벤트로 기록되기 때문에 원하는 시점으로 Rollback이 가능
      * 메시지 중심(Message-Driven) 아키텍처에 적합
      * Event Monitoring이 필요한 경우에 적합

    #### 단점
      * 상태 불일치가 발생할 수 있음
      * 업데이트 충돌 발생이 매우 적은 시스템에는 적합하지 않음
      * 데이터 뷰 일관성 및 실시간 업데이트가 필요한 시스템에는 적합하지 않음

## 아키텍쳐



# Java



# Spring



# DB & NoSql



# 디자인 패턴



# 자료구조



# 알고리즘



# 네트워크

  ## Http

  ## tcp/ip