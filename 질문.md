### 브라우저에 웹 주소를 입력할 때
1. 브라우저는 DNS 서버로 가서 웹사이트가 있는 서버의 진짜 주소를 찾습니다 (여러분이 상점의 주소를 찾습니다).
2. 그 다음 브라우저는 서버에게 웹사이트의 사본을 클라이언트에게 보내달라는 HTTP 요청 메세지를 서버로 전송합니다.(상점으로 가서 상품을 주문합니다.) 이 메세지, 그리고 클라이언트와 서버 사이에 전송된 모든 데이터는 TCP/IP 연결을 통해서 전송됩니다.
3. 이 메세지를 받은 서버는 클라이언트의 요청을 승인하고, "200 OK" 메세지를 클라이언트에게 전송합니다. "200 OK"는 "물론이죠. 당신은 웹 사이트를 볼 수 있어요! 여기 있어요" 라는 의미입니다. 그 다음 서버는 웹사이트의 파일들을 데이터 패킷이라 불리는 작은 일련의 덩어리들로 브라우저에 전송하기 시작합니다.(상점은 여러분이 주문한 상품을 전달하고, 여러분은 그것을 집으로 가져갑니다.)
4. 브라우저는 이 작은 덩어리들을 완전한 웹 사이트로 조립하고, 당신에게 보여줍니다. (상품이 당신의 문에 도착합니다. — 새 것이죠, 멋저요!)
(Http Request를 위해, TCP Socket을 개방하고, 연결한다. 이 과정에서 3-Hand-Shaking이 일어난다. TCP 연결에 성공하면, Http Request가 TCP Socket을 통해 보내진다. 이에 대한 응답으로, 웹 페이지의 정보가 사용자의 PC로 들어온다.)


### SSL(Secure Socket Layer) 통신 절차 
1. 클라이언트가 서버에 접속하면 서버인증서(서버의 공개키를 인증기관이 전자서명으로 인증한 것)를 전송받습니다. (이때, 클라이언트 인증을 필요로 할 경우 클라이언트의 인증서를 전송하게 됩니다.)
2. 클라이언트는 받은 서버 인증서를 분석하여 신뢰할 수 있는 인증서인지를 검토한 후, 서버의 공개키를 추출합니다.
3. 클라이언트가 세션키로 사용할 임의의 메세지를 서버의 공개키로 암호화하여 서버에 전송합니다.
4. 서버에서는 자신의 개인키로 세션키를 복호화하여 그 키를 사용하여 대칭키 암호방식으로 메시지를 암호화하여 클라이언트와 통신하게 됩니다.(https://)


### 로그를 아주 많이 찍어야 할때(성능)


### In-memory DB / File DB / NoSQL /  일반 RDBMS 의 차이점


### Java의 main method가 static 이유?
* static 자바 가상 머신에서 객체의 생성 없이 메모리에 할당시켜 호출 가능한 형태로 만듬.
* static이 아닌 일반 변수나 함수의 경우 객체가 생성되는 런타임(Runtime)시에 메모리에 할당되어 참조값(Reference)를 통하여 접근할 수 있음


### 클라이언트와 서버 통신에서 일련의 로그인 과정이 없이 인가된 클라이언트만 통신하게 하는 방법은?
* API Key : 특정 사용자만 알 수 있는 일종의 문자열
* 암호화 통신 : 서로 키를 공유해서 메시지를 암호화하여 통신
* 무결성 보장 : HMAC 기법(메시지 서명값)
* ssl

### Checked Exception과 Unchecked(Runtime) Exception?
1. Checked Exception
    * 반드시 예외를 처리해야함
    * 컴파일 단계
2. Unchecked(Runtime) Exception
    * 명시적인 처리를 강제하지 않음
    * 실행단계

### LRU(Least Recently Used), LFU(Least Frequently Used) 구현은 어떻게?


### 쓰레드 속도 개선 방법은?
* 비동기 + 멀티쓰레드 ?
* 블로킹 줄이기
* 락 경재 줄이기
* 락 구역 좁이기
* 락 스트라이핑 lock striping
* 핫 필드 최소화
* 객체 풀링은 하지 말자 (객체 풀링을 사용했을 경우에는 해당 풀에서 객체를 얻기 위한 경쟁이 발생하게 된다. 또 스레드가 대기상태에 들어가는 비용보다는 새로운 객체를 생성하는게 성능상 좋다.)


### 대용량 데이터 처리를 위한 서비스 아키텍처에 대해 설명?
* 마이크로 서비스 아키텍쳐(MSA)


### 자바의 GC는 어떻게 동작하나요
* GC의 대상 : 객체는 살아있는 Thread나 static 참조를 통해 도달할 수 없게 된다면 GC 대상이 된다. 
> 객체의 참조가 null 일 경우 </br>
> 객체가 블럭 안에서 생성되고 블럭이 종료되었을 경우 </br>
> 부모 객체가 null이 되었을 경우, 자식 또는 포함된 객체들은 자동적으로 GC 대상이 됨 </br>
> 객체가 Weak 참조만 가지고 있을 경우 </br>
> 객체가 Soft 참조이지만 메모리 부족이 발생한 경우 </br>

* JVM 힙
> 객체는 힙에 생성 </br>
> 힙은 Young, Tenured(=Old), Permanent(=Perm Area) Generation의 세 영역 </br>
> Young Generation은 Eden, Survivor1, Survivor2 영역 </br>
> 객체는 처음 생성될 때 Young Generation의 Eden 영역에 생성 </br>
> Minor GC 이후 객체가 살아있다면 Survivor1로 옮겨진다. </br>
> Major GC 전에 Survivor2의 객체는 Tenured Generation으로 옮겨진다. </br>
> Permanent Generation은 클래스나 메소드 등의 메타데이터를 저장하거나 String Pool의 공간으로 사용되어지는 조금 특별한 공간 </br>

* 과정 
> Marking : GC가 메모리가 사용되는지 아닌지를 찾음, 모든 오브젝트를 스캔하기 때문에 매우 많은 시간을 소모 </br>
> Normal Deletion : 참조되지 않는 객체를 제거하고, 메모리를 반환, 비어진 블럭의 참조 위치를 저장해 두었다고 새로운 오브젝트가 선언되면 할당되도록 함 </br>
> Compacting : 퍼포먼스를 향상시키기 위해,  참조되지 않는 객체를 제거하고 또한 남은 참조되어지는 객체들을 묶음 </br>