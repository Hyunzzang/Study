==================== 1 ====================
1. 생성자 대신 정적 팩터리 메서드르 고려하자.
* 이름을 가질 수 있다.
* 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
* 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
* 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
* 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

단점 : 
* public이나 protected로 선언된 생성자가 없으면 하위 클래스를 만들수 없다.
* 정적 팩터리 메서드가 다른 정적 메서드와 구분 되지 않음

2. 생성자에 매개변수가 많다면 빌더를 고려하라.
* 매개변수 개수가 많아질 경우
* 불변클래스로 만들수 있음
* 계층적으로 설계된 클래스와 함꼐 쓰기에 좋다

3. private 생성자나 열거타입으로 싱글턴임을 보증하라.

4. 인스턴스화를 막으려거든 private 생성자를 사용하라.
* util성 클래스

5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.
* 의존서이 높은 클래스는 직접 만들지 말고 의존 객체 주입 기법을 사용 의존을 주지 안도록(유연성, 재사용성, 테스트 용이성)

6. 불필요한 객체 생성을 피하라.
* string 같은 경우 new 생성 보다는 상수 값으로 제 사용 하도록
* 생성 비용이 비싼 객체는 캐싱하여 재사용 하도록
* 의미 없는 오토박싱 안되도록
* 일반적인 자체 객체 풀은 코드를 헷가리게 만들고 메모리 사용량을 느리고 성능을 떨어뜨림
* 객체를 재사용했을(방어적 복사가 필요한 상황) 때의 피해가 필요 없는 객체를 반복 생성했을 때의 피해보다 휠씬 크다

7. 다 쓴 객체 참조를 해제하라.
* 해당 참조를 다 썼을 때 NULL 처리(객체 참조를 null 처리하는 일은 예외적인 경우에)
* 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것(참조 햬제에 가장 좋은 방법)
* 캐시 사용시 WeakHashMap(weak reference) 사용

8. finalizer와 cleaner 사용을 피하라.
* finalizer는 예측 불가능
* 명시적인 종료 메소드를 하나 정의 하여 사용 하도록

9. try-finally 보다는 try-with-resources를 사용하라.
* JDK 1.7 부터 try-with-resources 구문이 추가 되었고, AutoCloseable 인터페이스가 추가

10. equals는 일반 규약을 지켜 재정의하라
  * 외만해서는 재정의하지 않는 것이 최선
  * 아래 사항에서는 재정의 하지 않는 것이 좋음
    - 각 인스턴스가 본질적으로 고유하다.
    - 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없다.
    - 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어 맞는다.
    - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
  * 재정의 해야 할때
    - 객체 식별성(object identity:두 객체가 물리적으로 같은가)이 아니고
    - 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않았을 때
    - 주로 값 클래스들이 해당(Integer와 String처럼 값을 표현하는 클래스)
    - 값 클래스라도 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의 하지 않아도 됨(Enum)
  * 재정의 규약(동치관계(equivalence relation)를 구현하며, 다음을 만족한다)
    - 반사성(reflexivity) :
    - 대칭성(symmetry) :
    - 추이성(transitivity) :
    - 일관성(consistency) :
    - null- 아님 :
  * 동치관계란 : 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산(이 부분집합을 동치류(동치 클래스)라 함)
  * 동치관계를 만족시키기 위한 다섯 요건
    - 반사성 : 객체는 자기 자신과 같아야 한다
    - 대칭성 : 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다
    - 추이성 : 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 셋 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다
    - 일관성 : 두 객체가 같다면 수정이 없는 한 영원히 같아야 한다.
    - null- 아님 : 모든 객체가 null과 같지 않아야 한다
  * equals 메서드 구현 방법을 단계별 정리
    1. ==연산자를 사용해 입력이 자기 자신의 참조인지 확인하다.(true이면 자기자신)
    2. instanceof 연산자로 입력이 올바른 타입이진 확인하다.
    3. 입력을 올바른 타입으로 형변환한다.
    4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.
  * float와 double을 제외한 기본 타입 필드는 == 연산자로 비교하고, 참조 타입 필드는 각각의 equals 메서드로, float와 double 필드는 각각의 정적 메서드인 compare로 비교
  * 어떤 필드를 먼저 비교하는냐가 성능을 좌우 한다.
  * equals를 재정의 할때 hashCode도 반드시 재정의 해라
  * 너무 복잡하게 해결하려 들지 말자. (동치성만 검사해도 규약을 지킬수 있음)
  * Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.
  * 작업을 대신해 주는 오픈 소스 AutoValue 프레임워크를 사용하자.
  
11. equals를 재정의 하려거든 hashCode도 재정의 하라
  * equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.

==================== 4 ====================
15.  클래스와 맴버의 접근 권한을 최소화 하라
* 클래스, 인터페이스, 맴버의 접근성을 명시하여 접근제한 (private, protected, public)
* 모든 클래스와 맴버의 접근성을 가능한 좁혀야 한다.
* 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정 할수 없다.
* public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
* public static final 필드는 불변으로 제공 해야 한다.
* public 가변필드는 스레드세이프 하지 않다.
* 클래스에서 public static final 배열필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서 안된다.(해결 방법은 public 불변 리스트 추가, 복사본을 반환하는 public 메서드 제공)
* 자바9의 모듈?

16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
* public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.

17. 변경 가능성을 최소화하라
* 불변 클래스의 다섯규칙
  1) 객체의 상태를 변경하는 메서드를 제공하지 않는다.
  2) 클래스를 확장할 수 없도록 한다. (final, 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공)
  3) 모든 필드를 final로 선언한다.
  4) 모든 필드를 private으로 선언한다.
  5) 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

* 불변 객체는 단순하면 스레드세이프 하면 안심하고 공유할 수 있다.
* 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 줄어든다.
* clone 메소드나 복사 생성자를 제공하지 않는게 좋다.
* 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리 내부 데이터를 공유할 수 있다.
* 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
* 단점 : 값이 다르면 반드시 독립된 객체로 만들어야 함.

* 다단계 연산(?)

18. 상속보다는 컴포지션을 사용하라
* 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
* 상속은 순수한 is-a 관계일 때만 사용

19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
* 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
* 상속 주의 문서를 @implSpec 태그를 붙여주면 자바독 도구가 생성
* 클래스의 내부 동작 과정 중간에 끼어들 수 있는 혹(hook)을 잘 선별하여 protected메소드 형태로 공개해야 할수도 있음
* 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
* 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
* 상속용으로 설계하지 않는 클래스는 상속을 금지하는 것이다.


20. 추상 클래스보다는 인터페이스를 우선하라.
* 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.
* 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다. 믹스인(?)
* 인터페이스로 계층구조가 없는 타입 프레임워크를 만들 수 있다.
* 인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 된다.
* 구현이 필요한 부분은 디폴트 메소드를 사용(주의: @implSpec으로 문서화,Object 메소드 재정의 할수 없음)
* 템플릿 메서드 패턴

21. 인터페이스는 구현하는 쪽을 생각해 설계하라
* 디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.
* 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필용한 경우가 아니면 피해야 한다.(기존 구현체들과 충돌 문제)

22. 인터페이스는 타입을 정의하는 용도로만 사용하라
* 상수 인터페이스를 사용하지 말라.(내부에서 사용할 상수를 외부로 노출되기 때문)
* 상수를 공개할 목적이라면 그 클래스나 인터페이스 자체게 추가, 열거 타입으로 적합한 상수라면 열거 타입으로, 그외의 경우라면 유틸리티 클래스으로 공개)

23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라
* 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.
* 계층 구조의 장점 간결하고 명확하면 쓸데없는 코드가 줄어듬(의미가 명확해짐)

24. 맴버 클래스는 되도록 static으로 만들라
* 중첩 클래스 종류 : 정적 맴버 클래스, 맴버 클래스, 익명 클래스, 지역 클래스(정정맴버클래스 제외한 나머지는 내부클래스(inner class))
* 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 함
* 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 맴버 클래스로 만들자.
* 맴버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 맴버 클래스로 만들자.

25. 톱레벨 클래스는 한 파일에 하나만 담으라
* 어느 소스 파일을 먼저 컴파일 하냐에 따라 동작이 달라 질수 있음
* 여러 톱레벨 클래스를 한 파일에 담고 싶다면 정적 맴버 클래스를 사용

==================== 5 ====================
26. 로 타입은 사용하지 말라.
  * 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때
  * 로 타입을 사용하면 오류가 발생 하더라도 컴파일 단계가 아닌 런타임 단계이기 때문에 문제
  * List<Object> 같은 매개변수화 타입을 사용할 때와 달리 List같은 로 타입을 사용하면 타입 안전성을 잃게 된다.
  * Set<?>는 모종의 타입 객체만 저장 할 수 있는 와일드 카드(타입 안전)
  
27. 비검사 경고를 제거하라.
  * 비검사 경고를 제거 하면 타입 안전성이 보장, 런타임에 ClassCastException이 발생할 일이 없음
  * 타입이 안전하다고 확신하면 @SuppressWarnings("unchecked") 달아 경고를 숨길수 있음. 사용시 좁은 범위에 적용하자. 안전한 이유를 주석으로 남기자.
  
28. 배열보다는 리스트를 사용하라.
  * 배열과 리스트의 차이 공변과 불공변
  * 배열은 런타임때 리스트는 컴파일일 때 알 수 있음
  * 배열은 재너릭 타입을 말들 수 없음(타입에 안전하지 않기 때문)
  
29. 이왕이면 제네릭 타입으로 만들라.
  * 배열을 제네릭으로 만들려 할때 문제가 발생
    - Object 배열을 생성한 다음 제네릭 배열로 형변환(타입이 안전하지 않다), 비검사 형변환으로 안전성을 확보하라.
    - 필드의 타입을 E[]에서 Object[]로 바꾼다.

30. 이왕이며 제네릭 메서드로 만들라
  * 매개변수와 반환값을 명시적으로 형변환해야 하는 메소드보다 제네릭 메서드가 안전하고 사용하기 좋다.
  
31. 한정적 와일드카드를 사용해 API 유연성을 높이라
  * <? extends E> 표현으로 하위타입도 사용 가능 하도록 할 수 있다.
  * <? super E> 표현으로 상위타입도 사용 가능
  * 입력 매개변수가 생상자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을게 없다.
  * 생산자면 <? extends E>, 소비자면 <? super E>
  * 반환 타입에는 한정적 와일드카드 타입을 사용하면 안됨
  * 메서드 선언에 타입 매개변수가 한번만 나오면 와일드 카드로 대체하라.
  
  * 와일드카드 타입을 실제 타입으로 바꿔주는 private  도우미 메서드란 ?
  
32. 제네릭과 가변인수를 함께 쓸 때는 신중하라.
  * 매개변수화 타입의 변수가 타입이 다른 객체를 참조하는 경우?
  
  * 제네릭과 varargs를 혼용하면 타입 안전성이 깨짐
  * 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.
  * 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 @SafeVarargs 사용하여 경고를 숨길 수 있음
  * @SafeVarargs 애너테이션은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치(메서드가 안전하지 않으면 사용하지 말라)
  * varargs 매개변수 배열이 호출자로부터 그 메서드로 순수하게 인수들을 전달하는 일만 한다면 그 메서드는 안전(재정의 할 수 없는 메서드에만 사용 해라)
  * 안전하지 않은 varargs 메서드는 절대 만들지 마라.
  * varargs 매개변수 배열에 아무것도 저장하지 않는다.
  * 배열 매개변수(혹은 복사본)을 신뢰할 수 없는 코드에 노출하지 않는다.
  * 자바 라이브러리에서 제공 하는 걸 사용 해라.
  
33. 타입 안전 이종 컨테이너를 고려하라
  * type safe heterogeneous container pattern(타입 안전 이종 컨테이너 패턴) ?
  * 비한정적?
  
  * 타입 안전 이종 컨테이너를 이용하면 한 컨테이너가 다룰 수 있는 타입 매개변수의 수을 무한정 사용 가능
  * Class를 키로 인스턴스를 값으로 구현 
  * 제약 사항
    - Class 객체를 로 타입으로 넘기면 favorites 인스턴스의 타입 안전성이 쉽게 깨짐
      (put 할때 인수로 주어진 instance의 타입이 type으로 명시한 타입(key)과 같은지 확인하면 문제를 해결 할 수 있음)
    - 실제화 불가 타입에는 사용 할 수 없다(예 - List<String>) 
  
==================== 6 ====================
  34. int 상수 대신 열거 타입을 사용하라
  * 열거타입은 일정 개수의 상수값을 정의한 다음, 그 외의 값은 허용하지 않는 타입
  * 정수 열거 패턴(int enum pattern) 단점(그냥 상수값)
    - 타입 안전을 보장할 방법이 없으며 표현력이 좋지 않다.
    - 깨지기 쉽다(상수의 값이 바뀌면 재 컴파일해야 함)
    - 정수 상수는 문자열로 출력하기가 까다롭다.
    - 문자열 상수의 경우에는 하드코딩 문제
  * 자바의 열거타입은 완전한 클래스, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개
  * 열거타입은 싱글턴의 일반화 형태, 컴파일타임 타입 안정성 제공
  * 열거타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
  * 열거타입은 근본적으로 불변이라 모든 필드는 final
  * 클래스 혹은 그 패키지에서만 유용한 기능은 private이나 package-private 메서드로 구현해라.
  * 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고, 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 맴버클래스로 만들라.
  * 추상 메서드를 선언하고 각 상수별로 클래스 몸체를 구현하여 상수별로 다르게 동작하는 코드를 구현할수 있다.

  * 열거 타입 상수는 생성자에서 자신의 인스턴스를 맵에 추가할 수 없다.(?)
  
  * 기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch문이 좋은 선택이 될 수 있다.
   - default 에 throw exception를 하여 추가 되었을 때 대비하자.
   
  * 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.
  
35. ordinal 메서드 대신 인스턴스 필드를 사용하라
  * ordinal 메서드란 열거 타입 상수값에 대응하는 정수값(몇번째위치) 반환하는 메소드
  * 열거 타입 상수에 연결된 값은 인스턴스 필드에 저장하여 사용하자.
  
36. 비트 필드 대신 EnumSet을 사용하라.
  * 원소가 총 64개 이하라면, long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여줌
  * 자바9 까지 불변 EnumSet 을 만들 수 없다.(Collections.unmodifiableSet 이용하면 되긴함)
  
37. ordinal 인덱싱 대신 EnumMap을 사용하라.
  * ordinal 인덱싱 문제점
    - 배열은 제네릭이 안됨 그래서 깔금한 컴파일이 안됨
    - 배열은 각 인덱스의 의미를 모르니 출력 결과에 직접 레이블을 달아야 함
    - 정수값이 사용하는 건 안전하지 않음 잘못된 동작을 할수 있음
  * EnumMap를 사용하면 배열 인덱싱의 문제를 해결 할수 있음
  
38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.
  * 열거 타입 자체는 확장할 수 없다. 하지만 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있음
  * 
  
39. 명명 패턴보다 애너테이션을 사용하라
  * 명명 패턴의 단점
    - 오타가 나면 안됨
    - 올바른 실행에 대한 보증할 방법이 없음
    - 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없음
  * 애너테이션을 사용 위 문제를 해결 할 수 있음
  * 애너테이션의 제약을 걸려면 직접 구현해야 함
  * 자바8에서는 @Repeatable 메타애너테이션을 사용하여 여러 개의 값을 받을 수 있음

40. @Override 애너테이션을 일괄되게 사용하라
  * 상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 애너테이션을 달자 그러면 의도치않는 다중정의 했을 때 문제등을 컴파일 단계에 발견 할 수 있음
  
41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라
  * 마커 인터페이스(marker interface) : 메서드를 갔지 않고, 특정 속성만 가짐을 표시해 주는 인터페이스(예: Serializable)
  * 마커 인터페이스와 마커 애너테이션은 각자의 장점이 있음
  * 새로 추가하는 메서드 없이 단지 타입 정의가 목적이면 마커 인터페이스(적용 대상을 더 정밀하게 지정할 수 있음)
  * 클래스, 인터페이스 외의 프로그램 요소에 마킹해야 하거나, 애너테이션을 적극 활용 하는 프레임워크의 일부로 그 마커를 편입하고자 한다면 마커 애너테이션
  
==================== 7 ====================
42. 익명 클래스보다는 람다를 사용하라
  * 익명 클래스보다 코드가 깔금(간결함)
  * 람다는 함수형 인터페이스에서만 쓰임
  * 익명 클래스는 타입의 인스턴스를 만들 때만 사용(함수형 인터페이스가 아닐 경우)
  * 람다는 문서화가 못함. 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
  * 람다는 자신을 참조 할수 없음, 람다에서의 this 키워드는 바깐 인스턴스를 가르킨, 반면 익명 클래스에서는 익명 클래스의 인스턴스 자신을 가르킴
  * 람다를 직력화하는 일은 극히 삼가해야 함.(가상머신별로 다를 수 있음)
  
43. 람다보다는 메서드 참조를 사용하라.
  * 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용
  
44. 표준 함수형 인터페이스를 사용하라.
  * 기본 함수형 인터페이스 6개는 꼭 기억하자.
  * 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자.
  * 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안된다.
  
45. 스트림은 주의해서 사용하라.
  * 다량의 데이터 처리 작업을 돕고자~
  * 스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워진다.
  * 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘다 해보고 더 나은 쪽으로 택하라.
  
46. 스트림에서는 부작용 없는 함수를 사용하라.
  * 순수 함수를 사용하라(오직 입력만이 결과에 영향을 주는 함수)
  * forEach 연산은 스트림 계산 결과를 보고 할때만 사용하고, 계산하는 데는 쓰지 말자.
  *   
  
47. 반환 타입으로는 스트림보다 컬렉션이 낫다.
  * 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는게 일반적으로 최선이다.
  * 덩치 큰 시퀀스를 메모리에 올려서는 안 됨( 대안 AbstractList)
  
48. 스트림 병렬화는 주의해서 적용하라.
  * 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.
  * 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병령화의 효과가 가장 좋음.(원하는 크기로 나눌수 있기 때문에)
  * 병렬화할 때 가장 중요한 요소는 참조 지역성(기본 타입의 배열이 가장 좋음)
  * 종단연산 중 병렬화에 가장 적합한 것은 축소(reduction),
    - 축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업(min, max, count, sum)
    - anyMatch, allMatch, noneMatch 처럼 조건에 맞으면 바로 반환되는 메소드도 병렬화에 적함
  * 가변축소(mutable reduction)를 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.(합치는 부담이 큼)
  * 직접구현한 Stream, Iterable, Collection이 병렬화의 이점을 제대로 누리게 하고 싶다면 spliterator 메서드를 반드시 재정의 하라.
  * 보통의 병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로 다른 부분의 성능에 까지 악영향을 줄 수 있음


==================== 8 ====================
49. 매개변수가 유효한지 검사하다.
  * 제약 조건은 반드시 문서화
  * 메서드 몸체가 시작되기 전에 검사
  * public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화(@throws)
  * null 체크는 java.util.Objects.requireNonNull를  사용하자
  * private 메소드는 유효값만 넘겨지도록 하자.
  
50. 적시에 방어적 복사본을 만들라.
  * Date 는 사용 말라.
  * 생성장에서 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy)해야 한다.
  * 방어적 복사본을 만들고, 복사본으로 유효성 검사를 하라(멀티스레딩에 안전)
  * 매개변수가 제3자에 의해 확장될 수 있는 타입이면 복사본을 만들때 clone을 사용하지 말라.
  * 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 짐재적으로 변경 될 수 있는지 고려하자.
  * 방어적 복사를 하지 않는다면 문서화 하자(클라이언트에 책임 있다)
  
51. 메소드 시그니처를 신중히 설계하라.
  * 메소드 이름을 신중히 짓자.
  * 편의 메서드를 너무 많이 만들지 말자.
  * 매개변수 목록을 짧게 유지하자.(4이하, 같은 타입의 매개변수 연달아는 최악)
  * 매개변수 줄이는 기술 (1. 여러 메서드로 쪼갠다, 2. 매개변수를 묶어주는 도우미 클래스 사용) 
  * 매개변수의 타입으로는 클래스보다는 인터페이스
  * boolean보다는 원소 2개짜리 enum 타입으로
  
52. 다중정의는 신중히 사용하라.
  * 오버로딩에서 어느 메서드를 호출할지는 컴파일타임에 정해진다.
  * 재정의한 메소드는 동적으로 선택, 다중정의한 메서드는 정적으로 선택 됨
  * 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 마라.
  * 가변인수는 사용 하는 경우에는 다중정의를 아예 사용 하지 마라.
  * 예매 할 경우에는 이름 다르게 하거나 생성자의 경우에는 정적 팩터리가 대안
  * 메서드를 다중정의할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서 안 된다.(-Xlint:overloads 다중정의 경고)

53. 가변인수는 신중히 사용하라.
  * 인수의 개수는 런타임에 배열의 길이로 알 수 있음
  * 가변인수의 개수를 1이상만 받도록 설계 하는 건 좋지 않다.
  * 필수 인수는 가변인수 앞에 두자
  * 가변인수 메소드는 호출 할 때마다 배열을 메모리에 할당하고 초기화 하기 때문에 성능에 좋지 않다.
  * 성능을 고려 해야 한다면 EnumSet의 정적 팩터 기법을 사용하자.
  
54. null 이 아니, 빈 컬렉션이나 배열을 반환하라
  * 빈 배열을 반환 할 때 미리 할당하는 건 추천하지 않는다.

55. 옵셔널 반환은 신중히 하라.
  * 옵셔널을 반환하는 메소드에서는 절대 null을 반환하지 말자.
  * 옵셔널을 사용하면 반환값이 없을 수도 있음을 API 사용장에게 알려준다.
  * isPresent 메소드는 신중하게 사용하자. 다른 옵셔널 메소드로 대처 가능 한진 생각 해 보자.
  * 자바9에서는 옵셔널에 stream() 메소드가 추가 되었다.
  * 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안됨.
  * Optional<T>로 선언해야 할때는 결과가 없을 수 있으면, 클라이언트가 이 상황을 특별하게 처리해야 할때
  * 성능이 중요하다면 Optional 사용을 신중히 생각 하자.
  * 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록 하자.(OptionalInt, OptionalLong, OptionalDouble)
  * 옵셔널을 Map의 값으로 절대 안됨(컬렉션의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없음)
  * 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.
  
56. 공개된 API 요소에는 항상 문서화 주석을 작성하라.
  * 자바독을 사용하여 문서화 하자.
  * 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.(전제조건과 사후조건, 부작용에 관한 내용을 기술)
  * 클래스를 상속용으로 설계 할때는 자기사용 패턴(self-use pattern)에 대해서도 문서에 남겨야 한다.(@implSec)
  * 한 클래스(혹은 인터페이스) 안에서 요약 설명이 똑같은 맴버(혹은 생성자)가 둘 이상이면 안된다.
  * 주석 작성 할때 마침표(.)에 주의 하자.(마침표까지는 표시됨)
  * 자바 9 부터는 색인 기능 추가(@index)
  * 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.
  * 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.
  * 애너테이션 타입을 문서화할 때는 맴버들에도 모두 주석을 달아야 한다.
  * 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다.
  * 직력화할 수 있는 클래스라면 직렬화 형태도 API 설명에 기술해야 한다.
  * {@inheritDoc} 태그를 사용해서 사위 타입의 문서화 주석 일부를 상속할 수 있다.

==================== 9 ====================
57. 지역변수의 범위를 최소화하라
  * 지역변수의 유효범위를 최소화 하면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아짐
  * 지역변수의 범위를 줄이는 강력한 기법은 가장 처음 쓰일 때 선언하기
  * 지역변수는 선언과 동시에 초기화 해라
  * 반복 변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while 문보다는 for 문을 쓰는 편이 낫다
  * 메서드를 작게 유지하고 한 가지 기능에 집중하는 것(메서드를 기능별로 쪼갬)
  
58. 전통적인 for 문보다는 for-each 문을 사용하라
  * for-each를 사용하면 interator와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류를 방지 할수 있다.
  * for-each문을 사용할 수 없는 사항
    - 파과적인 필터링(destructive filtering) ?
    - 변형(transforming)
    - 병렬반복(parallel iteration)
  * for-each 를 사용 하려면 컬렉션, 배열, Iterable 인터페이스
  
59. 라이브러리를 익히고 사용하라
  * 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
  * Random 사용하지 말라. ThreadLocalRandom을 사용 해라. 포크조인 풀이나 병렬스트림에서는 SplittableRandom을 사용해라.
  * 핵심적인 일과 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 됨
  * 따로 노력하지 않아도 성능이 지속해서 개선됨
  * 기능이 점점 많아짐
  * 다른 개발자들과 공유가 쉬워짐
  * java.lang, java.util. java.io 와 그 하위 패키지들에는 익숙해져라(컬렉션 프레임워크, 스트림 라이브러리)
  
  서드파티 라이브러리에는 뭐가 있을까?
  
60. 정확한 답이 필요하면 float와 double은 피하라.
  * 넓은 범위의 수를 빠르게 정밀한 근사치로 계산하도록 설계됨
  * 금융 관련 계산에는 사용하면 안됨
  * 금용 계산에는 BigDecimal, int, long을 사용해야 함
  * BigDecimal의 단점
    - 기본타입보다 쓰기가 불편하고 느림

61. 박싱된 기본 타입보다는 기본 타입을 사용하라.
  * 박싱된 기본 타입 : 기본 타입에 대응하는 참조 타입(Integer, Double, Boolean)
  * 기본타입과 박싱된 기본 타입의 차이
    - 기본타입은 값만 가지고 있고, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖음(값이 같아도 같지않음)
    - 기본타입의 값은 언제나 유효하나(null값이 없음),  박싱된 기본 타입은 유효하지 않는 값을 가질수 있음(null)
    - 기본타입이 박싱된 기본타입보다 시간과 메모리 사용면에서 더 효율적
  * 박싱된 기본 타입에 == 연산자를 사용하면 오류가 발생(주의하자)(Comparator.naturalOrder()을 사용해라)
  * 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀림
  * 박싱된 기본 타입이 적절히 쓰이는 경우
    - 컬렉션의 원소, 키, 값 으로 사용
    - 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로 사용 할때
    - 리플렉션을 통해 메서드를 호출 할때
    
62. 다른 타입이 적절하다면 문자열 사용을 피하라.
  * 문자열은 다른 값 타입을 대신하기에 적합하지 않다.수치형이라면 int, float, BigInteger등 적당한 수치 타입으로, 에/아니오는 boolean으로 변환 해라
  * 문자열은 열거 타입을 대신하기에 적합하지 않다.
  * 문자열은 혼합 타입을 대신하기에 적합하지 않다.
  * 문자열은 권한을 표현하기에 적합하지 않다.
  
63. 문자열 연결은 느리니 주의하라
  * 문자열 연결 연산자(+)로 문자열 n개를 잇는 시간은 n2에 비례 한다. 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할수 없다.
  * 성능을 생각한다면 StringBuilder를 사용해라.
  
64. 객체는 인터페이스를 사용해 참조하라.
  * 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
  * 인터페이스를 타입으로 사용하면 프로그램이 유연해 질 걸.
  * 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 (상위의) 클래스를 타입으로 사용하자.
  
65. 리플렉션보다는 인터페이스를 사용하라.
  * 리플렉션의 단점
    - 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
    - 코드가 지저분하고 장황해짐
    - 성능이 떨어짐
  * 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용해라.
  
66. 네이티브 메서드는 신중히 사용하라
  * JNI의 주요 쓰임
    - 레지스트리 같은 플랫품 특화 기능
    - 네이티브 코드로 작성된 기존 라이브러리를 사용
    - 성능에 결정적인 영향을 주는 부분(권장 하지 않음)
  * 안전하지 않고 메모리 훼손 오류 문제, 이식성 문제, 디버깅도 어려움, 잘못 사용하면 속도도 느려 질수 있음
  
67. 최적화는 신중히 하라
  * 최적화 규치
    - 하지마라.
    - 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.
    - 각각의 최적화 시도 전후로 성능을 측정하라
  * 빠른 프로그램 보다는 좋은 프로그램을 작성하라.
  * 성능을 제한하는 설계를 피하라.
    - 컴포넌트끼리, 혹은 외부 시스템과의 소통방식(API, 네트워크 프로토콜, 영구 저장용 데이터 포맷)
  * API를 설계할 때 성능에 주는 영향을 고려하라.
    - (아이템50, 18, 64)
  * 보통 잘 설계된 API는 성능도 좋다. 성능을 위해 API를 왜곡하는 건 매우 안좋다.
  * 프로파일링 도구는 최적화 하는데 도움을 준다.

68. 일반적으로 통용되는 명명 규칙을 따르라
  * 자바 언어 명세[JTS, 6.1]
  * 자바의 명명 규칙은 크게 철자와 문법
  * 철차규칙
    - 패키지은 조직의 인터넷 도메인 역순으로 사용한다.
    - 패키지의 한요소는 8자리 이하로 한다.
    - 요소의 이름은 보통 한 단어 혹은 약어로 이뤄진다.
    - 클래스와 인터페이스의 이름은 하나 이상의 단어로, 각 단어는 대문자로 시작, 약자나 통용되는 줄임말을 제외 하고는 단어를 줄여 쓰지 않도록 한다.
    - 메소드와 필드 이름은 첫 글자를 소문자로 쓴다는 점만 빼면 클래스 명명 규칙과 같다.
    - 상수 필드는 모두 대문자로 쓰며 단어 사이는 밑줄로 구분
    - 지역변수에도 다른 맴버와 비슷한 명명 규칙이 적용, 단 약어를 써도 좋다.
    - 타입 매개변수 이름은 보통 한 문자로 표현, 임의 타임엔 T, 컬렉션 원소 타임은 E, 맵의 키와 값은 K,V, 예외는 X, 메소드의 반환타입은 R
      그 외에 임의 타입의 시퀀스에는 T,U,V 혹은 T1, T2, T3를 사용
  * 문법규칙
    - 클래스 명사나 명사구
    - 객체를 생성할 수 없는 클래스는 보통 복수형 명사
    - 인터페이스 이름은 클래스와 똑같이 짖거나, able 혹은 ible로 끝나는 형용사로 짖는다.
    - 애너테이션은 워낙 다양하게 활용되어 지배적인 규칙이 없이 명사, 동사, 전치사, 형용사가 두루 쓰임
    - 메서드는 동사나 동사구
    - boolean 값을 반환하는 메서드라면 보통 is나 has로 시작하고 명사나 명사구, 혹은 형용사로 기능하는 아무 단어나 구로 끝나도록 짓는다
    - 반환 타입이 boolean이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구 혹은 get으로 시작하는 동사구로 짓는다.
    - 메서드 이름 규칙
      -- 객체의 타입을 바꿔서, 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드의 이름은 보통 toType 형태
      -- 객체의 내용을 다른 뷰로 보여 주는 메서드의 이름은 asType 형태
      -- 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 보통 typeValue 형태
      -- 정적 팩터리의 이름은 보통 from, of, valueOf, instance, getInstance, newInstance, getType, newType
    - 필드 이름 규칙
      -- boolean 타입의 필드 이름은 보통 boolean 접근자 메서드에서 앞 단어를 뺀 형태
      -- boolean 외 타입은 명사나 명사구(지역변수 이름도 비슷)
  

==================== 10 ====================
69. 예외는 진짜 예외 상황에만 사용하라.
  * try-catch 블록 안에 코드를 넣으면 JVM이 적용할 수 있는 최적화가 제한됨
  * 예외를 사용한 쪽이 표준 관용구보다 훨씬 느림
  * 예외를 잘못사용하면 예외 발생시 예외를 잡지 못하여 정상적으로 종료되어 예외를 처리가 힘들어 질수 있음
  
70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.
  * throwable 타입에는 검사 예외(Exception), 런타임 예외(RuntimeException), 에러(Error) 세 가지 있음
  * 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
  * 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.(복구하기 힘든 예러)
  * Error는 상속 하지 말고 RuntimeException를 사용하여 하위 클래스를 만들어 사용하라.
  * Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들지 마라.
  * 감사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.
  
71. 필요 없는 검사 예외 사용은 피하라.
  * 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.(과하면 불편한 API가 된다)
  * API를 제대로 사용해도 발생하는 예외나 프로그래머가 의미 있는 조치를 할수 있을 때만 사용 하도록 하자.
  * 검사 예외가 오직 하나 일때는 안 던지는 방법이 없는지 고민 해 보자.
  * 검사 예외를 회피하는 가장 쉬운 방법은 결과 타입을 담은 옵셔널을 반환하는 것, 옵셔널로 반환이 힘들 때만 검사 예외를 사용 하자.

72. 표준 예외를 사용하라.
  * 표준 예외를 사용하면 다른 사람이 익히고 사용하기 쉬워지고, 코드 분석이 쉬우면 예외 클래수 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸림
  * Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.(여러 성격의 예외들을 포괄하는 클래스)
  * 예외는 직렬화할 수 있다는 사실을 기억하자.
  
73. 추상화 수준에 맞는 예외를 던지라.
  * 예외번역(exception translation) : 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.
  * 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄(exception chaining)를 사용하는게 좋다.
  * 예외 연쇄란 문제의 근본원인 저 수준 예외를 고수준 예외에 실어 보내는 방식
  * 최선책은 저수준 메서드가 반드시 성공하도록하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선(아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 처리 할수 있음)
  * 아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않는 방법(로깅 기능을 활용하여 기록 하자)
  
74. 메서드가 던지는 모든 예외를 문서화하라.
  * 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화 하자.
  * 공통 상위 클래스 하나로 뭉뚱그려 선언하지 말라.
  * 비검사 예외도 문서화를 잘 하자.
  * 메소드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.(둘을 확실히 구분찍자)
  * 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 (각각의 메서드가 아닌) 클래스 설명에 추가하는 방법도 있다.
  
75. 예외의 상세 메시지에 실패 관련 정보를 담으라.
  * 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 매시지에 담아야 한다.(보안에 주의 하자)
  
76. 가능한 한 실패 원자적으로 만들라.
  * 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.(실패 원자적(failure-atomic))
  * 메소드를 실패 원자적으로 만드는 방법
    - 불변 객체로 설계 하자
    - 작업 수행에 앞서 매개변수의 유효성을 검사 하자.(잠재적 예외를 걸러내자)
    - 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것
    - 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법

77. 예외를 무시하지 말라.
  * catch 블록을 비워두면 예외가 존재할 이유가 없다(무시하지 말자)
  * 만약 무시하기로 했다면 이유를 주석으로 남기자. 예외 변수의 이름도 ignored로 바꿔놓도록 하자.
  * 무시하지 않고 바깥으로 전파되게만 놔둬도 최소한 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할수 있다.
  
==================== 11 ====================
78. 공유 중인 가변 데이터는 동기화해 사용하라
  * 동기화는 베타적 수행과 스레드 간 통신이라는 두 가지 기능을 수행
  * synchronized : 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장
    - 객체를 하나의 일관된 상태에서 다른 일관된 상태로 변환 시킴(lock)
    - 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.
    - 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해줌
  * 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요
  * Thread.stop은 사용하지 말라.
  * 동기화하지 않으며 메인 스레드가 수정한 값을 백그라운드 스레드가 언제쯤에나 보게 될지 보증할 수 없음
  * 쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않음
  * volatile 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장
  * volatile은 배타적 수행 시 주의 해야 한다. (예: 일련번호 생성)
  * atomic 패키지의 클래스 들은 원자성을 보장한다.(스레드 세이프)
  * 멀티 스레드 환경에서는 불변 데이터만 공유하거나 아무것도 공유하지 말자.(가변데이터는 단일 스레드에서만 사용하자)
  * 객체를 안전하게 발행하는 방법 : 정적필드, volatile 필드, final 필드, 혹은 보통의 락을 통해 접근 하는 필드에 저장, 동시성 컬렉션 사용
  
79. 과도한 동기화는 피하라
  * 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳음
  * 응답 불가와 언전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안됨
  * 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안됨, 클라이언트가 넘겨준 함수 객체를 호출 해서도 안됨
  * (교체에서) 리스트를 복사해 사용하면 락 없이도 안전하게 사용 가능(CopyOnWriteArrayList 사용하면 더 좋음)
  * 열린 호출(Open Call) : 동기화 영역 바깥에서 호출되는 외계인 메소드
  * 열린 호출은 실패 방지 효과외에도 동시성 효율을 크게 개선해 줌
  * 동기화 영역에서는 가능한 한 일을 적게 하자.
  * 가변 클래스 작성 선택지
    - 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
    - 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.[아이템 82](클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 사용 하자)
  * 선택하기 어렵다면 동기화하지 말고, 대신 문서에 "스레드 안전하지 않다"고 명기 하자.
  * 클래스 내부에서 동기화 한다면, 락 분할(lock splitting), 락 스트라이핑(lock striping), 비차단 동시성 제어(nonblocking concurrency control)등의 기법을 사용해 보자.
  
80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
  * ExecutorService 주요 기능
    - 특정 태스크가 완료되기를 기다린다.
    - 태스크 모음 중 아무것 하나(invokeAny 메서드) 혹은 모든 테스크(invokeAll 메소드)가 완료 되기를 기다린다.
    - 실행자 서비스가 종료하기를 기다린다(awaitTermination 메서드)
    - 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용)
    - 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(ScheduledThreadPoolExecutor 이용)
  * 작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋음(일반적인 용도에 적함, 무거운 프로덕션 서버에는 좋지 않음)
  * 무거운 프로덕션 서버에는 스레드 개수를 고정한 Executors.newFixedThreadPool 을 선택하거나 완전히 통제할 수 없는 ThreadPoolExecutor를 사용 해라
  * 작업 큐를 손수 만드는 일은 삼가해라, 스레드를 직접 다루는 것도 일반적으로 삼가 해라.
  * 실행자 프레임워크은 작업 단위와 실행 메커니즘이 분리
  * 작업 단위는 테스크에서 (Runnable, Callable)
  * ExecutorService 실행 매커니즘
  * 자바 7에서는 fork-join 
    
   81. wait와 notify 보다는 동시성 유틸리티를 애용하라
  * 고수준 유틸리티의 세범주 
    - 실행자 프레임워크
    - 동시성 컬렉션(concurrent collection) : 표준 컬레션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션
    - 동기화 장치(synchronizer)
  * 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려짐
  * 동시성을 무력화 못하므로 여러 기본 동작을 하나의 원자적 동작으로 묶는 상태 의존적 수정 메서드들 지원(예 - putIfAbsent 등)
  * 동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해줌
  * 가장 자주 쓰이는 동기화 장치는 CountDownLatch와 Semaphore 이며 CyclicBarrier와 Exchanger는 그 보다 덜 쓰임, 그리고 Phaser는 가장 강력한 동기화 장치
  * 시간 간격을 잴 때는 항상 System.currentTimeMillis 보다 System.nanoTime을 사용하자
  * wait 메서드를 사용할 때는 반드시 대기 반복문(wait loop) 관용구를 사용하라. 반복문 밖에서는 절대로 호출하지 말자.
  * 스레드를 깨울 때에는 notify 보다는 notifyAll를 사용하여 에러를 줄이수 있음
  * notify를 사용한다면 응답 불가 상태에 빠지지 않도록 각별히 주의 하자
  
82. 스레드 안전성 수준을 문서화하라
  * 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일 뿐 api에 속하지 않음, 이것만으로는 그 메서드가 스레드 안전하다고 믿기 어렵음
  * 멀티스레드 환경에서도 api를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야함
  * 스레드 안전성 높은 순 나열
    1. 불변(immutable)
    2. 무조건적 스레드 안전(unconditionally thread-safe)
    3. 조건부 스레드 안전(conditionally thread-safe)(컬렉션들이 반환한 반복자는 외부에서 동기화해야 함)
    4. 스레드 안전하지 않음(not thread-safe)
    5. 스레드 적대적(thread-hostile)
  * 서비스 거부 공격을 막으려면 synchronized 메서드 대신 비공객 락 객체를 사용해야 한다.(락 필드는 항상 final로 선언하라)
  * 비공개 락 객체 관용구는 무조건적 스레드 안전 클래스에서만 사용할 수 있음
  
83. 지연 초기화는 신중히 사용하라
  * 지연 초기화(lazy initialization)는 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법
  * 정적 필드와 인스턴스 필드 모두에 사용 할 수 있음
  * 필요할 때까지는 사용하지 말라
  * 멀티스레드 환경에서는 지연 초기화를 하기가 까다로움 반드시 동기화 해야 함
  * 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 좋음
  * 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스(lazy initialization holder class) 관용구를 사용하라
  * 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사(double-check) 관용구를 사용하라(초기화 할때 동기화 비용을 없애줌) volatile로 선언해야 함
  
84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라
  * 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫품에 이식하기 어렵다.
  * 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하자.
  * 실행 가능한 스레드 수를 적게 유지하는 주요 기법은 각 스레드가 작업을 완료한 후에는 일이 생길 때까지 대기 하도록 하는 것
  * 스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안됨
  * 스레드는 바쁜대기(busy waitting) 상태가 되면 안됨(공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안됨)
  * Thread.yield를 사용해서 cpu시간을 얻는 작업은 하지 말자.
  * 스레드 우선순위는 자바에서 이식성이 가장 나쁜 특성에 속함, 이식성이 떨어짐
  
  
https://www.baeldung.com/java-util-concurrent